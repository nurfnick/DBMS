\documentclass[11pt]{article}
\usepackage{hyperref}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage{ wasysym }

\newtheorem{example}{Example}


\author{}
\title{}

\begin{document}
%\maketitle
{\Large
%Change Document name to: Graded Homework 1\_Jacob\_Nicholas
\noindent NAME:  Nicholas Jacob\\ 
STUDENT ID: \# 113578513\\
GRADED HOMEWORK NUMBER: 4\\
COURSE: CS/DSA 4513 DATABASE MANAGEMENT\\ 
SECTION: ONLINE\\SEMESTER: FALL 2023\\
INSTRUCTOR:  DR. LE GRUENWALD\\
 SCORE:}

\newpage
\begin{enumerate} 
\item 
\begin{enumerate}
\item Find the name of each employee who works for ``Big Bank".
\[
\Pi_{person\_name}(\sigma_{company\_name = ``Big Bank"}(works))
\]
\item Find the name and city of each employee who works for ``Big Bank".
\[
\Pi_{person\_name, city}(\sigma_{company\_name = ``Big Bank"}(employee \bowtie_{%employee.person\_name = works.
person\_name} works))
\]
\item Find the name, street address, and city of each employee who works for ``Big Bank" and earns more than \$10 000.
\begin{eqnarray*}
\Pi_{person\_name,street, city}(
\sigma_{(salary > 10 000) \land (company\_name = ``Big Bank")}(\\employee \bowtie_{%employee.person\_name = works.
person\_name} works)))
\end{eqnarray*}
\item Find the name of each employee who lives in the same city as the company for which they work.
\begin{eqnarray*}
\Pi_{person\_name}
(
\sigma_{employee.city = company.city}
((
employee \bowtie_{%employee.person\_name = works.
person\_name} works)\\
\bowtie_{company\_name} company)
)
\end{eqnarray*}

\end{enumerate}
\item Given the relational schema Employee(id, name, classid,gender, manager,salary) and the set of Functional Dependencies 

FD = 

\{(classid,id,gender)$\rightarrow$ (salary, manager),

name $\rightarrow$ (age,id), 

id$\rightarrow$ name, 

manager $\rightarrow$ (gender, age, classid,id)\}
\begin{enumerate}
\item To find all candidate keys, we will first examine the closure $FD^+$.  Using decomposition, we see that 

manager $\rightarrow$ gender,

manager $\rightarrow$ age,

manager $\rightarrow$ classid,

manager $\rightarrow$ id,

Then we grab the penultimate and the last here and use transitivity so,

manager $\rightarrow$ name.

To show manager is a candidate key, I still need salary.  We see from decomposition that 

(classid,id,gender)$\rightarrow$ salary, and

manager $\rightarrow$ (gender, classid,id) so transitivity gives us

manager $\rightarrow$ salary.  Thus manager is a superkey.  You cannot simplify manager so it is also a candidate key.

The other superkey is (classid, id, gender).  We see right away that its closure contains salary and manager (decomposition rule).  With this addition, we can also add age (decomposition again).  We also get id trivially (reflexivity) so name will be included.  Thus we have shown that all elements belong to the superkey (classid, id, gender).  We note that this set is minimal.  Closure on any of the individual or combination of elements will not give you manager.  Thus (classid, id, gender) is a candidate key.

We do not see any other keys.  id and name had the best shot but both do not imply manager so you are stuck.
\item Normal Forms
\begin{enumerate}
\item This relational schema is in the first normal form since all entries are atomic.
\item To check for second normal form, we would need for any non-prime attribute to be fully dependent on the candidate key.  We see that name is partially dependent on the candidate key (classid, id, gender) since id $\rightarrow$ name.
\item We are not third normal form either.  name $\rightarrow$ age is in the closure (by decomposition).  But age is not in any of the candidate keys so not third normal form as age is not a prime attribute.
\item Since we were not third normal form, we will not be BCNF.  We can see this by definition too.  name $\rightarrow$ age is again a issue.  name is not a superkey. 
\end{enumerate}
\item Since I was 1NF and 2NF but not 3NF, I will decompose with the desired result being 3NF.  We first take each of the relations and build a schema from each. 

$R_1$(classid, id,gender, salary, manager)

$R_2$(name, age, id)

$R_3$(id, name)

$R_4$(manager, age, classid, id,gender )


We see that $R_1$, $R_4$ contain a candidate key. So we proceed to the next step of eliminating redundant relations.

$R_1$(classid, id,gender, salary, manager)

$R_2$(name, age, id)


I think I have removed all the redundant sets, so now it is time to identify the functional dependencies on each.  The candidate key for $R_1$ is (classid, id, gender).  For $R_2$ it is name.  The functional dependencies would be (classid, id,gender) $\rightarrow$ (salary, manager) and manager $\rightarrow$ (gender, age, classid,id) on $R_1$. name $\rightarrow$ (age,id) and id $\rightarrow$ name on $R_2$.  (name, id) is a superkey on $R_2$ with name being a candidate key and (classid,id,gender, manager) is a superkey with (classid,id,gender) or manager being a candidate key.


\item This is a lossless join.  As long as I did it correct, the 3NF decomposition is supposed to be lossless but we'll examine the details.  We need to show that the intersection of all the sets create a functional dependancy that was in the closure of the original.  Start with $R_1$.  We intersect that with $R_2$ and see that the element id survives.  We note that id $\rightarrow$ (name,age,id) so this abides the lossless requirements $R_1\cap R_2 \rightarrow R_1$.

\item This is a dependency preforming join.  Again the 3NF decomposition is supposed to be dependency preserving.  I haven't done it correctly because I lost manager $\rightarrow$ age.


Try again...

\item I think the decomposition should be 

$R_1$(CIGS)

$R_2$(CIGM)

$R_3$(NA)

$R_4$(NI)

$R_5$(MA)

then superkeys are cig, cigm, n, ni, m.  Dependencies preserved are cig$\rightarrow$ s,cig$\leftrightarrow$ m, n$\rightarrow$a, n$\leftrightarrow$i, m$\rightarrow$ a.

\item I am having trouble showing the lossless join.  I think I join 1 and 2.  Join that with 5.  Then join up 3 and 4 (all of these are lossless) then join together.  This is called the chase (https://stackoverflow.com/questions/21560069/lossless-join-decomposition-more-than-two-relations)
\end{enumerate}
\end{enumerate}






\end{document}